# 设计工程

### 一、设计概述

#### 1. 什么是设计？什么是设计模型？

   * 将问题转化成解决方案的创造性的活动。
   * 对解决方案的描述

   

#### 2. 概念设计

   > 告诉顾客系统将要做什么；用顾客语言而不是技术术语；描述系统的功能；独立于实现；与需求相关
   >

   **概念设计确定**：软件系统的结构、各模块功能及模块间联系(接口)

   **概念设计的过程**：设想可能的方案=>选取合理的方案=>推荐最佳方案=>功能分解=>设计软件结构=>数据库设计=>制定测试计划=>编写文档=>审查与复审

   

#### 3. 技术设计

   > 告诉程序员系统将要做什么
   >
   > 包括：主要硬件组件和功能、软件组件的层次和功能、数据结构、数据流

   技术设计的主要任务：

1. 编写技术设计说明书：确定每个模块的算法，用工具表达算法的过程，写出模块的详细过程性描述、确定每一模块的数据结构、确定模块接口细节

2. 技术(详细)设计是编码的先导。

   

#### 4. 五种创建设计的方法

   * Modular decomposition 模块分解：将功能分配给组件
   * Data-oriented decomposition 面向数据的分解：基于外部数据结构
   * Event-oriented decomposition 面向事件的分解：基于系统必须处理的事件和事件改变系统的状态信息
   * Outside-in design 由外而内的设计：基于系统的用户输入（属黑盒方法）
   * Object-oriented design OO 设计：确定对象的类和他们之间的相互关系

   

#### 5. 三种设计层次

   * Architecture体系结构：系统性能与系统组件关联起来
   * Code design代码设计：为每个组件详细说明算法和数据结构
   * Executable design执行设计：设计的最低级别，包括内存分配、数据格式和位组合

   

#### 6. 软件体系结构的风格

> 三个方面：组件(模块)、连接器(组件间的联系)、组件(模块)组合的限制条件

1. **管道和过滤器**：组件是管道，将各个管道用连接器链接
   * 性质：关系表示明确；复用、修改、模拟容易；允许并发执行过滤器
   * 局限性：更适合批处理(不适合交互式处理)；数据流之间需要对应
2. **隐含调用(事件驱动)**：某个组件宣告时间，其他组件处理时间，利用注册程序处理时间
   * 优点：易于复用其他系统组件；对用户界面尤其有用
   * 缺点：不能确定某个事件的响应；测试系统很难
3. **Layering分层**：各层分等级，每层为它外层提供服务
   * 优点：表示不同的抽象层次；对层的修改通常只影响相邻的两层
   * 缺点：需求阶段定义多层抽象很困难；性能问题
4. **解释器**：解释器读入字符串并将它们转换成可以执行的实际代码，一般用来构建虚拟机。



#### 7.优秀设计的特征

1. **组件独立性**：

   * 组件独立是模块化、抽象、信息隐蔽和局部化的直接结果
   * 含义：一个模块具有独立功能而且和其它模块之间没有过多的相互作用
   * 意义：独立的模块容易开发(规模小，接口简单)；独立的模块容易测试和维护；有效阻断错误传播
   * 度量标准：内聚和耦合

   >  **耦合性**：指块间里联系，即程序结构中不同模块之间互连程度。耦合的强弱取决于模块间接口的复杂程度和调用模块的方式。
   >
   >  * 内容耦合：一个模块可以直接操作另一个模块的数据(如go to语句的使用)
   >  * 公共耦合：全局结构类型的数据
   >  * 控制耦合：模块间传递的是诸如标记量的控制信息
   >  * 标记耦合：参数传递的是诸如结构类型的数据
   >  * 数据耦合：参数传递的是一般类型的数据
   >  * 非直接耦合：通过上级模块进行联系，无直接关联
   >
   >  
   >
   >  **内聚性**：块内联系或模块强度，指模块内各个成分彼此结合的紧密程度，即模块内部的聚合能力；理想的模块仅仅做一件事。
   >
   >  * 功能性内聚：一个功能一个模块，块内各成分属于一个整体
   >  * 顺序内聚：模块内各个组成部分都是与一个功能密切相关，并是顺序执行的。一般是一个成分的输出就是下一个成分的输出
   >  * 通讯内聚：模块内的各个成分都是用统一输入数据，或产生同一输出数据，即借公用数据而联系在一起
   >  * 过程内聚：块内成分必须按照特定次序执行
   >  * 时间内聚：因执行时间一样或顺序排列而把几个任务安排一个模块，如把变量赋初值、打开文件等完成各种初始化任务安排在一个模块
   >  * 逻辑内聚：块内任务间在逻辑上相似或相同，例如求某班的平均分和最高分，因其输入和输出相同而安排在一个模块内完成。
   >  * 偶然(巧合)内聚：一个模块所完成的几个任务之间关系松散，互不相关。主要是为了避免重复书写而把重复的代码集成到一个模块内。

   **启发式规则的应用**：

   > 启发式规则是一种经验规律，对改进设计和提高软件质量具有重要的参考价值，但不要过分拘泥于这些规则。

   * 提高模块独立性：高内聚、低耦合

   * 设计规模适中的模块：分解模块不应该降低模块独立性

   * 深度、宽度、扇入、扇出适中

     > **深度**：软件结构中控制的层数。一般而言它与系统的复杂度和系统大小直接对应。
     >
     > **宽度**：软件结构中同一个层次上的模块总数的最大数。
     >
     > **扇出**：一个模块直接调用的模块数目。扇出过大说明模块过分复杂，过小也不好，不利于系统分解平衡。
     >
     > **扇入**：一个模块的扇入是指直接控制该模块的模块数目。扇入越大说明共享该模块的上级模块越多。
     >
     > 整个系统结果呈现椭圆外型。

   * 模块的作用域应该在控制域之内

     > **控制域**：控制范围，是包括模块本身以及所有下属模块(直接调用或者间接调用模块)的集合。
     >
     > **作用域**：作用范围，他是一个与条件判定相联系的概念。是受改模块内一个判定影响的所有模块的集合。
     >
     > **改进方法**：判定上移或在作用域但不在控制域的模块下移

   * 降低接口的复杂性

   * 设计单入口和单出口的模块

   * 设计功能可以预测的模块

   

2. **例外设计与处理**：

   * 无法提供某种服务
   * 提供了错误的服务或数据
   * 破坏性的数据
   * 防御式编程

3. **防错和容错**：



#### 8.设计的评估和确认

1. 初步设计评审：同顾客与用户一起审查概念设计。
2. 关键设计审查：向开发人员展示技术设计。
3. 程序设计审查：程序员在实现之前获得对他们设计的反馈。





# 二、面向对象设计的主要工作

#### 1.用例实现方案精化

> 可以利用UML的交互图（顺序图、协作图），用于用例实现方案的表示。

1. 提取边界类、实体类和控制类

   **边界类**：描述系统与外部环境的交互。(通常与用户相连接)

   * 界面控制：包括输入数据的格式及内容转换，输出结果的呈现，软件运行过程中界面的变化与切换等。
   * 外部接口：实现目标软件系统与外部系统或外部设备之间的信息交流和互操作。主要关注跨越目标软件系统边界的通信协议。
   * 环境隔离：将目标软件系统与操作系统、数据库管理系统、应用服务器中间件等环境软件进行交互的功能与特性封装于边界类之中，使目标软件系统的其余部分尽可能地独立于环境软件。

   **控制类**：控制类作为完成用例任务的责任承担着，协调、控制其他类共同完成用例规定的功能或行为。对于比较复杂的用例，控制类通常并不处理具体的任务细节，但是它应知道如何分解任务，如何将子任务分派给适当的辅助类，如何在辅助类之间进行消息传递和协调。

   **实体类**：实体类标识目标软件系统中具有持久意义的信息项及其操作

   

   **如何从分析模型中获取这些类**：

   * 执行者与用例之间的一种通信连接对应一个边界类。但是如果两个以上的用例与同一执行者交互，并且这些交互具有共同的行为、完成相同或类似的任务，就可以考虑用统一边界类实现用例与执行者之间的交互。这就意味着边界类的作用范围可以超越单个用例。
   * 实体类源于分析模型。有时也需要认真研读用例描述，从中发掘具有持久意义的信息项。
   * 一个用例通常对应一个控制类。
   * 如果不同用例的任务有较多类似之处，也可以考虑在多个用例的实现方案中共享同一控制类，此种情况应审慎对待，不同用例所需要的控制、协调行为往往会有差异。

   

2. 构造交互图

   >  将分析模型中的用例描述转化成UML交互图，以交互图作为用例的精确实现方案。

   * 用例描述中已包含事件流说明。
   * 事件流中的事件应直接对应于交互图中的消息，而事件间的先后关系体现为交互图中的时序，对消息的响应则构成消息接受者的职责。

   包含控制类和边界类的UML顺序图：用例的主动执行者、用户界面的边界类、控制类、实体类和辅助类、外部接口和环境隔离层的边界类、目标软件系统的边界之外的被动执行者。**按此布局，在顺序图中不应该出现穿越可控制类生命线的消息。**

   当需要强调类之间的联系时可协作图。包含控制类和边界类的协作图布局规则：

   * 控制类位于中心
   * 主动执行者和环境隔离层的边界类位于左上方
   * 作为外部接口和环境隔离层的边界类位于右上方
   * 辅助类和实体类分别位于控制类的左下、右下方

   

3. 精化类图

   可以利用交互图精化分析模型中的类图，将交互图中出现的新类添加到原有类图中，并且对相关的类进行精化，并最终确定各类的方法和属性。注意，这是一个反复迭代的过程。



#### 2.软件体系结构(软件架构)

> 一个系统的基础组织，包含各个构件、构件互相之间与环境的关系，还有指导其设计和演化的原则。
>
> 任何具有固定组成形式的数据、代码、数据集合、代码序列、数据和代码的结合体都可以称作结构。无论多么高层的结构，都是建立在基础结构之上的。软件结构的问题**从最初的最基本、最底层的描述过度到越来越高、越来越抽象的层次上。**

1. 主流软件体系结构

   * 客户、服务器模式：客户端负责用户输入和处理结果的程序，服务端负责后台业务处理。

   * 分层模式：将整个软件系统分成若干层次，最顶层直接面向用户提供软件系统的操作界面，其余各层为紧邻其上的层次提供服务。(可以有效的降低软件系统的耦合度，应用普遍)

   * MVC模式：将人机交互从核心功能中分离出来；模型对用户来说是不可见的，用户只需要观察视图；用户与模型的交互通过控制器提供的安全方法拉实现。

     

2. 体系结构图

   * 定义原始模型，系统的体系结构可由这些原始模型组成。原始模型可从前面的分析设计中获得。
   * 对体系结构设计是一个逐步精化的过程。
   * 将体系结构精化为构建，当体系结构精化为构件时，系统的结构开始显现。

   > 可使用包图或组件图来标识体系结构图



#### 3.构件设计

> 构件设计将软件体系结构的结构元素变换为对软件构件的过程性描述，从基于类的模型、动态模型和静态模型等获得的信息作为构件设计的基础。

* 在相对较低的抽象层次上详细的说明所有算法。
* 精化每个构件的结构。
* 定义构件级数据结构。
* 评审每个构件并修正所有已发现的错误。



#### 4.数据持久存储服务

> 设计数据持久存储服务的目的是将软件系统中依赖于系统运行环境的数据存取部分与其他部分分离。数据存取通过一般的数据管理系统实现。

数据持久存储服务的设计包括，定义数据格式和定义数据存储操作两部分。

1. 定义数据格式：根据目标软件系统对数据存储的需求，考虑持久存储介质的特性，设计数据的存储格式。
   * 针对文件系统，需要定义用于保存数据的文件类别、每类文件的记录格式；
   * 针对关系数据库，需要定义表格的字段名称、类型、关键字、约束条件等；
   * 针对面向对象数据库，数据格式的定义相对简单，因为该数据库支持对象的存储和读取。
2. 定义数据存取操作：数据持久存储服务至少包含数据的存储和读取两种操作。
   * 存储操作负责将实体对象中的属性数据写至持久存储介质
   * 读取操作则负责从持久存储介质中的序列化数据恢复对象的属性值。
   * 数据存取操作一般以服务类的形式为系统的其他部分提供数据持久存储服务。
   * 在引入持久存储服务之后，目标软件系统的其他部分对持久存储介质的访问必须通过该服务进行，不能直接访问。



#### 5.设计用户界面

>设计阶段要给出有关人机交互的所有系统成 份，包括:用户如何操作系统、系统如何响应命令、系统显示信息的报表格式等。



#### 6.精化设计模型

* 以顶层架构图为基础，精化目标软件系统的体系结构。
* 精化类之间的关系。
* 精化类的属性和操作。
* 针对具有明显状态转换特征的类设计状态图。
* 针对比较复杂的类方法，设计活动图。



# 三、面向对象设计的原则工作

#### 1.单一职责原则(SRP)

> 一个类应该有且只有一个改变的理由。即每一个类应该只专注于做一件事。

* SRP原则衡量的标准——内聚。你写了高内聚的软件其实就是说你很好的应用了SRP原则。
* 怎么判断一个职责是不是一个对象的呢?你试着让这个对象自己来完成这个职责，比如:“书自己阅读内容”，阅读的职责显然不是书自己的。



#### 2.开放——关闭原则(OCP)

>  软件实体应该可以扩展，但不可以修改。

**开放**:从哲学上其实是要我们在设计和开发软件时提高抽象层次，不要总在具体对象层面上进行处理。

**关闭**:设计好的类一定要对修改关闭.



#### 3.里氏代换原则(LSP)

> 子类型应该能代替掉父类型，且代替后程序运行情况不会错乱。



#### 4.依赖导致原则(DIP)

> * 高层模块不应该依赖于低层模块，两者都应该依赖于抽象。
> * 抽象不应该依赖于细节，细节应该依赖于抽象。



#### 5.接口隔离原则(ISP)

> 不应该强迫客户依赖于他们不要的方法。接口属于客户，不属于他所在的类层次结构